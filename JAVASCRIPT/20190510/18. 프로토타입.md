# 18. 프로토타입
* 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어
* 자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다.

## 1. 객체지향 프로그래밍
* 객체지향 프로그래밍(Object Oriented Programming, OOP)은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍(Imperative programming)의 절차지향적 관점에서 벗어나 프로그램을 여러 개의 독립적 단위, 즉 객체(object)들의 집합으로 표현하려는 프로그래밍 패러다임을 말한다.
* 속성을 통해 어떠한 사물이나 개념을 구체화하는 것이다.
* 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려 내어 표현하는 것을 추상화(abstraction)라 한다.
* 객체지향 프로그래밍은 객체의 상태(atate)를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작(behavior)을 하나의 논리적인 단위로 묶어 생각한다. 이때 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조를 객체(object)라 한다.
* 객체의 상태 데이터를 프로퍼티(property), 동작을 메소드(method)라 부른다.
* 각 객체는 자신의 고유한 기능을 수행하면서 다른 객체와 관계성(relationship)을 갖을 수 있다.

## 2. 상속과 프로토타입
* 상속(inheritance)은 객체지향 프로그래밍의 핵심 개념으로 상위(부모) 객체의 프로퍼티 또는 메소드를 하위(자식) 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.
* 자바스크립트는 프로토타입(prototype)을 기반으로 상속을 구현한다.

## 3. 프로토타입 객체
* 프로토타입 객체(또는 줄여서 프로토타입)란 객체 지향 프로그래밍의 근간을 이루는 객체간 상속(inheritance)을 구현하기 위해 사용된다.
* 프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메소드 포함)를 제공한다.
* 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.
* 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정된다.
* 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다.
* 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다.
* 생성자 함수는 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.

### 1. 객체의 __proto__ 접근자 프로퍼티
* 모든 객체는 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다.
* __proto__ 접근자 프로퍼티는 getter/setter 함수라고 부르는 접근자 함수를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다.
* __proto__ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천이다.
* 프로토타입의 참조를 취득할 경우는 Object.getPrototypeOf 메소드를, 프로토타입을 교체하는 경우는 Object.setPrototypeOf 메소드를 사용하는 것을 권장한다.
* __proto__ 접근자 프로퍼티는 상속을 통해 사용된다.
* 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함이다.

### 2. 함수 객체의 prototype 프로퍼티
* 함수 객체는 __proto__ 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.
* prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.

### 3. 프로토타입의 constructor 프로퍼티와 생성자 함수
* 모든 프로토타입은 constructor 프로퍼티를 갖는다.
* constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.
* 이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다.

## 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
* 리터럴 표기법에 의해 생성된 객체의 경우, 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.
* 프로토타입의 constructor 프로퍼티로 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 크게 무리는 없다.

## 5. 프로토타입의 생성 시점
* 생성자 함수는 사용자가 직접 정의한 사용자 정의 생성자 함수와 자바스크립트가 기본 제공하는 빌트인 생성자 함수로 구분할 수 있다.
* 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

### 1. 사용자 정의 생성자 함수와 프로토타입 생성 시점
* constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
* 함수 선언문으로 정의된 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 된다. 이때 프로토타입도 더불어 생성된다. 생성된 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩된다.

### 2. 빌트인 생성자 함수와 프로토타입 생성 시점
* Object, String, Number, Function, Array, RegExp, Date, Promise 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다.
* 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 전역 객체는 누구보다도 먼저 생성된다.
* 전역 객체는 누구보다도 먼저 생성된다. 전역 객체가 생성된 이후, 빌트인 객체가 생성되어 프로퍼티로 추가된다.

## 6. 객체 생성 방식과 프로토타입의 결정
* 객체는 아래와 같이 다양한 생성 방법이 있다.
  * 객체 리터럴
  * Object 생성자 함수
  * 생성자 함수
  * Object.create 메소드
  * 클래스 (ES6)
* 이와 같이 다양한 방식으로 생성된 모든 객체는 각각의 방식 마다 세부적인 객체 생성 방식의 차이는 있으나 추상 연산 ObjectCreate에 의해 생성된다는 공통점을 갖는다.
* 프로토타입은 추상 연산 ObjectCreate에 전달되는 인수(proto)에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.
  
### 1. 객체 리터럴에 의해 생성된 객체의 프로토타입
* 자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 ObjectCreate를 호출한다.
* 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다.

### 2. Object 생성자 함수에 의해 생성된 객체의 프로토타입
* Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 ObjectCreate를 호출한다.
* 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다.

### 3. 생성자 함수에 의해 생성된 객체의 프로토타입
* new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다.
* 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다.
* 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다.

## 7. 프로토타입 체인
* 자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 __proto__ 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이것을 프로토타입 체인이라 한다. 
* 프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다. Object.prototype을 프로토타입 체인의 종점(End of prototype chain)이라 한다.
* 프로토타입 체인의 종점인 Object.prototype에서도 프로퍼티를 검색할 수 없는 경우, undefined를 반환한다. 이때 에러가 발생하지 않는 것에 주의하자.

## 8. 캡슐화
* 캡슐화(encapsulation)는 정보의 일부를 외부에 감추어 은닉(정보 은닉(information hiding))하는 것을 말한다. 즉, 외부에 공개할 필요가 없는 구현의 일부를 외부에 노출되지 않도록 감추어 적절치 못한 접근으로부터 정보를 보호하고 객체간의 상호 의존성, 즉 결합도를 낮추는 효과가 얻는다.

## 9. 오버라이딩과 프로퍼티 쉐도잉
* 프로토타입이 소유한 프로퍼티(메소드 포함)를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부른다.
* 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. 이때 인스턴스 메소드는 프로토타입 메소드를 오버라이딩하였고 프로토타입 메소드는 가려진다.

## 10. 프로토타입의 교체
* 프로토타입은 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체 간의 상속 관계를 동적으로 변경할 수 있다.

### 1. 생성자 함수에 의한 프로토타입의 교체
* 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다.
* 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살린다.

### 2. 인스턴스에 의한 프로토타입의 교체
* 인스턴스의 __proto__ 접근자 프로퍼티(또는 Object.setPrototypeOf 메소드)를 통해 프로토타입을 교체할 수 있다.

## 11. instanceof 연산자
* instanceof 연산자는 이항 연산자로서 좌변에 객체를 가기키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우, TypeError가 발생한다.
* `객체 instanceof 생성자 함수`
* 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스라면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다.

## 12. Object.create에 의한 직접 상속
* Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.
* Object.create 메소드도 다른 객체 생성 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다.
* 객체를 생성하면서 직접적으로 상속을 구현한다.
* 장점
  * new 연산자가 없이도 객체를 생성할 수 있다.
  * 프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다.
  * 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.
* 그런데 ESLint에서는 위 예제와 같이 Object.prototype의 빌트인 메소드를 객체가 직접 호출하는 것을 비추천하고 있다. 그 이유는 Object.create 메소드를 통해 프로토타입 체인을 생성하지 않는 객체를 생성할 수 있기 때문이다.

## 13. 객체 리터럴 내부에서 __proto__에 의한 직접 상속
* Object.create 메소드는 직접 상속은 위와 같이 여러 장점이 있다. 하지만 두번째 인자로 프로퍼티를 정의하는 것은 번거롭다.
* ES6에서는 객체 리터럴 내부에서 __proto__ 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.

## 14. 정적 프로퍼티/메소드
* 정적(static) 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다.
* 정적 프로퍼티/메소드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.

## 15. 프로퍼티 존재 확인
* in 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다.
* `prop in object`
* in 연산자는 확인 대상 객체(위 예제의 경우, person 객체)의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의하기 바란다.
* Object.prototype.hasOwnProperty 메소드를 사용해도 객체의 프로퍼티의 존재 여부를 확인할 수 있다.

## 16. 프로퍼티 열거
* 객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in 문을 사용한다. for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다
* `for (변수선언문 in 객체) { … }`