# 13.9 Angular Component - Interaction

## 1. 컴포넌트의 계층적 트리 구조
* 분할된 컴포넌트를 조립한다는 것은 컴포넌트를 다른 컴포넌트에서 사용하는 것을 말하는데, 이는 컴포넌트 간에 계층(Hierarchy)적 구조가 형성될 수 있음을 의미한다.
* 분할된 컴포넌트를 조립하여 구성된 애플리케이션은 컴포넌트 간의 부모-자식 관계로 표현되는 계층적 트리 구조를 갖는다.
* 계층적 구조는 DOM 트리와 유사한 형태를 가지게 되는데 이를 컴포넌트 트리라고 한다.
* 컴포넌트 간의 부모-자식 관계는 데이터와 이벤트가 왕래하는 상태 정보 흐름의 통로가 되며 이를 통해 다른 컴포넌트와의 상태 공유가 이루어진다.
* Angular가 제공하는 컴포넌트 간에 상태 정보를 공유할 수 있는 방법
  * @Input, @Output 데코레이터
  * @ViewChild, @ViewChildren과 @ContentChild, @ContentChildren 데코레이터
  * 서비스 중재자 패턴을 구현한 상태 공유 서비스
  * 상태 관리를 위한 외부 라이브러리(ngrx/store, Redux 등) 사용

## 2. 부모 컴포넌트와 자식 컴포넌트의 상태 공유
### 1. 부모 컴포넌트에서 자식 컴포넌트로 상태 전달
#### 1. @Input 데코레이터
* form 요소를 가지고 있는 부모 컴포넌트의 경우, 사용자에 의해 상태(state)가 변경되면 이를 자식 컴포넌트와 공유할 필요가 있다. 이러한 경우 부모 컴포넌트는 프로퍼티 바인딩을 통해 자식 컴포넌트에게 상태 정보를 전달한다.
* 자식 컴포넌트는 부모 컴포넌트가 전달한 상태 정보를 @Input 데코레이터를 통해 컴포넌트 프로퍼티(입력 프로퍼티)에 바인딩한다. 이때 자식 컴포넌트는 어떤 컴포넌트가 상태 정보를 전달하였는지는 알 필요가 없고, 단지 전달된 정보의 타입만 알 필요가 있다. 이것은 다른 컴포넌트와 결합도를 낮게 유지하면서 다른 컴포넌트와 상태 정보를 교환할 수 있다는 것을 의미한다.
* @Input 데코레이터 바로 뒤의 프로퍼티명과 부모 컴포넌트에서 실행한 프로퍼티 바인딩의 프로퍼티명은 반드시 일치하여야 한다.
* 부모 컴포넌트와 자식 컴포넌트는 동일한 참조를 갖는다. 따라서 참조를 공유하고 있는 프로퍼티를 어느 한쪽에서 변경하면 모두에게 변경이 반영된다.
* 만약에 부모 컴포넌트에서 실행한 프로퍼티 바인딩의 프로퍼티명과는 다른 프로퍼티명을 자식 컴포넌트에서 사용하려면 @Input 데코레이터에 프로퍼티 바인딩의 프로퍼티명을 인자로 전달하고 사용하고자 하는 프로퍼티명을 선언한다. 이때 @Input 데코레이터에 전달한 문자열은 부모 컴포넌트에서 실행한 프로퍼티 바인딩의 프로퍼티명과 반드시 일치하여야 한다.

#### 2. @Input 데코레이터와 setter를 이용한 입력 프로퍼티 조작
* setter와 getter를 사용하여 부모 컴포넌트가 전달한 데이터가 자식 컴포넌트의 입력 프로퍼티에 바인딩되는 시점에 필요한 로직을 동작시킬 수 있다.
* 부모 컴포넌트가 전달한 데이터에서 필요한 값을 추출하거나 검사 또는 변형할 때 setter는 매우 유용하다.

### 2. 자식 컴포넌트에서 부모 컴포넌트로 상태 전달
#### 1. @Output 데코레이터와 EventEmitter
* 자식 컴포넌트에서 부모 컴포넌트로 상태 정보를 전달하는 방법
* 자식 컴포넌트는 @Output 데코레이터와 함께 선언된 컴포넌트 프로퍼티(출력 프로퍼티)를 EventEmitter 객체로 초기화한다. 그리고 부모 컴포넌트로 상태를 전달하기 위해 emit() 메소드를 사용하여 이벤트를 발생시키면서 상태를 전달한다. 부모 컴포넌트는 자식 컴포넌트가 전달한 상태를 이벤트 바인딩을 통해 접수한다.
* EventEmitter 객체는 커스텀 이벤트를 발생시키는 emit 메소드를 가지고 있다.
* 부모 컴포넌트는 이벤트 바인딩을 통해 자식 컴포넌트가 발생시킨 이벤트를 접수한다. 이때 자식 컴포넌트가 emit 메소드를 호출하면서 인자로 전달한 상태 정보는 $event에 들어 있다.

## 3. Stateful 컴포넌트와 Stateless 컴포넌트
* 부모 컴포넌트와 자식 컴포넌트 모두 상태 객체에 대한 동일한 참조를 갖는다. 따라서 참조를 공유하고 있는 상태 객체를 어느 한쪽에서 변경하면 모두에게 변경이 반영되는데 이는 상태 정보의 변화를 예측하기 어렵게 만든다.
* 간단한 구조로 되어 있다면 문제가 되지 않겠지만 복잡한 계층적 구조를 갖는 애플리케이션의 경우, 컴포넌트마다 상태 정보를 마음대로 변경할 수 있다면 상태 변경을 추적하기 어렵고 의도하지 않은 상태 정보의 변경이 발생하여 문제가 될 수 있다.
* 애플리케이션의 상태 정보를 저장하고 변경할 수 있는 Stateful 컴포넌트(Smart 컴포넌트)와 상태 정보를 참조하여 화면에 출력할 뿐 직접 변경하지 않는 Stateless 컴포넌트(Dumb 컴포넌트)로 구분할 필요가 있다.
* Stateful 컴포넌트는 애플리케이션의 현재 상태 정보를 관리하며 필요에 따라 서버 자원에 접근할 수 있고 Stateless 컴포넌트를 사용하여 뷰를 표현한다. 
* Stateless 컴포넌트는 부수 효과(side effect)를 발생시키지 않는 순수 함수(pure function)와 유사하게 단순히 프로퍼티 바인딩을 통해 상태 정보를 전달받아서 뷰를 렌더링하고 필요에 따라 이벤트를 방출할 뿐, 그 외의 부수 효과는 발생시키지 않는다.

## 4. 원거리 컴포넌트 간의 상태 공유
* 복잡한 컴포넌트 트리 구조를 갖는 애플리케이션의 경우, 부모-자식 관계를 뛰어넘어 컴포넌트 간의 상태 공유가 필요할 수 있다.
* 불필요한 상태 공유를 피하기 위해 상태 공유를 위한 서비스를 사용할 수 있다.